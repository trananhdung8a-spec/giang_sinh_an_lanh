<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas 3D - High Quality Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; }
        
        /* UI Styling */
        #interface {
            position: absolute; bottom: 40px; width: 100%;
            text-align: center; pointer-events: none; z-index: 10;
        }
        
        .status-bar {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px; border-radius: 20px;
            color: #ffd700; font-size: 14px;
            display: inline-block; border: 1px solid #ffd700;
            margin-bottom: 20px; backdrop-filter: blur(5px);
        }

        #start-btn {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(135deg, #ff0000 0%, #8b0000 100%);
            color: white; border: 2px solid #ffd700;
            padding: 18px 60px; border-radius: 50px;
            font-weight: bold; font-size: 18px;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            transition: all 0.3s;
        }
        #start-btn:hover { transform: scale(1.1); box-shadow: 0 0 40px #ff0000; }

        /* Camera Preview Optimization */
        #camera-canvas {
            position: absolute; top: 20px; right: 20px;
            width: 300px; height: auto;
            border: 3px solid #ff4444; border-radius: 12px;
            transform: scaleX(-1); /* Mirror effect */
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            background: #111;
        }

        #watermark {
            position: absolute; bottom: 15px; right: 20px;
            color: rgba(255,255,255,0.4); font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="interface">
        <div class="status-bar">
            üñê Open: Explode | ‚úä Fist: Tree | ‚úåÔ∏è Pinch: View Photo
        </div><br>
        <button id="start-btn">K√çCH HO·∫†T PH√âP THU·∫¨T</button>
    </div>

    <div id="watermark">¬© Designed by vandiep</div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-canvas"></canvas>

    <script>
        // --- C·∫§U H√åNH H·ªÜ TH·ªêNG ---
        const CONFIG = {
            particleCount: 2500,
            treeHeight: 75,
            treeRadius: 38,
            explodeRadius: 70,
            orbitRadius: 40,
            cameraHD: { width: 1280, height: 720 }
        };

        let scene, camera, renderer, clock;
        let groupGold, groupRed, groupGifts;
        let photoMeshes = [], starMesh, titleMesh, loveMesh;
        let state = 'TREE', selectedIndex = 0;
        let handX = 0.5, handY = 0.5, lerpHandX = 0.5, lerpHandY = 0.5;
        let bgMusic;

        // --- KH·ªûI T·∫†O TEXTURES ---
        const loader = new THREE.TextureLoader();
        const photoFiles = [
            './image1.jpeg.jfif', './image2.jpeg.jfif', './image3.jpeg.jfif', './image4.jpeg.jfif', 
            './image5.jpeg.jfif', './image6.jpeg.jfif', './image7.jpeg.jfif', './image8.jpeg.jfif', 
            './image9.jpeg.jfif', './image10.jpeg.jfif'
        ];
        const photoTextures = photoFiles.map(file => loader.load(file));

        function generateCircleTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.3, color);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- KH·ªûI T·∫†O C√ÅC OBJECT 3D ---
        function createScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.set(0, 10, 120);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // T·∫°o c√°c nh√≥m h·∫°t
            groupGold = buildParticles(0xffd700, CONFIG.particleCount, 1.8);
            groupRed = buildParticles(0xff0000, 400, 3.5);
            groupGifts = buildGifts(150);

            createPhotoSphere();
            addLightsAndDecor();
        }

        function buildParticles(colorHex, count, size) {
            const geo = new THREE.BufferGeometry();
            const pos = [], treeTargets = [], explodeTargets = [], heartTargets = [];
            
            for(let i=0; i<count; i++) {
                // T·ªça ƒë·ªô C√¢y th√¥ng (Cone)
                const h = Math.random() * CONFIG.treeHeight;
                const r = (1 - h/CONFIG.treeHeight) * CONFIG.treeBaseRadius; // L·ªói nh·ªè ·ªü ƒë√¢y bi·∫øn ch∆∞a ƒë·ªãnh nghƒ©a, fix:
                const realR = (1 - h/CONFIG.treeHeight) * CONFIG.treeRadius * Math.sqrt(Math.random());
                const angle = Math.random() * Math.PI * 2;
                treeTargets.push(realR * Math.cos(angle), h - 35, realR * Math.sin(angle));

                // T·ªça ƒë·ªô N·ªï (Sphere)
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = 2 * Math.PI * Math.random();
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
                explodeTargets.push(rad * Math.sin(phi) * Math.cos(theta), rad * Math.sin(phi) * Math.sin(theta), rad * Math.cos(phi));

                // T·ªça ƒë·ªô Tr√°i tim
                const t = Math.random() * Math.PI * 2;
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const rFill = Math.pow(Math.random(), 0.5);
                heartTargets.push(hx * rFill * 2.5, hy * rFill * 2.5, (Math.random()-0.5)*10);

                pos.push(treeTargets[i*3], treeTargets[i*3+1], treeTargets[i*3+2]);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                size: size, color: colorHex, map: generateCircleTexture('#fff'),
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            
            const points = new THREE.Points(geo, mat);
            points.userData = { tree: treeTargets, explode: explodeTargets, heart: heartTargets };
            scene.add(points);
            return points;
        }

        function buildGifts(count) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff4444'; ctx.fillRect(10, 10, 44, 44);
            ctx.fillStyle = '#ffd700'; ctx.fillRect(28, 10, 8, 44); ctx.fillRect(10, 28, 44, 8);
            
            const tex = new THREE.CanvasTexture(canvas);
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) pos.push(0, 0, 0);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({ size: 4, map: tex, transparent: true });
            const points = new THREE.Points(geo, mat);
            points.userData = { 
                tree: new Array(count*3).fill(0).map(() => (Math.random()-0.5)*60),
                explode: new Array(count*3).fill(0).map(() => (Math.random()-0.5)*150)
            };
            scene.add(points);
            return points;
        }

        function createPhotoSphere() {
            const geo = new THREE.PlaneGeometry(12, 12);
            for(let i=0; i<10; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                
                // Add border
                const border = new THREE.Mesh(new THREE.PlaneGeometry(13, 13), new THREE.MeshBasicMaterial({color: 0xffd700}));
                border.position.z = -0.05; mesh.add(border);

                // Fibonacci Sphere Distribution
                const phi = Math.acos(-1 + (2 * i) / 9);
                const theta = Math.sqrt(10 * Math.PI) * phi;
                mesh.userData.spherePos = new THREE.Vector3(
                    CONFIG.orbitRadius * Math.cos(theta) * Math.sin(phi),
                    CONFIG.orbitRadius * Math.sin(theta) * Math.sin(phi),
                    CONFIG.orbitRadius * Math.cos(phi)
                );
                
                mesh.visible = false;
                photoMeshes.push(mesh);
                scene.add(mesh);
            }
        }

        function addLightsAndDecor() {
            // Ng√¥i sao ƒë·ªânh c√¢y
            const starGeo = new THREE.SphereGeometry(4, 16, 16);
            starMesh = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({color: 0xffff00}));
            starMesh.position.y = 42;
            scene.add(starMesh);

            // Title "Merry Christmas"
            const loaderTitle = new THREE.FontLoader(); // Gi·∫£ l·∫≠p title b·∫±ng Canvas
            const titleCanvas = document.createElement('canvas');
            titleCanvas.width = 1024; titleCanvas.height = 256;
            const tCtx = titleCanvas.getContext('2d');
            tCtx.font = 'bold 80px Arial'; tCtx.fillStyle = '#ffd700';
            tCtx.textAlign = 'center'; tCtx.fillText("MERRY CHRISTMAS", 512, 150);
            const titleTex = new THREE.CanvasTexture(titleCanvas);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 20), new THREE.MeshBasicMaterial({map: titleTex, transparent: true}));
            titleMesh.position.set(0, 55, 0);
            scene.add(titleMesh);
        }

        // --- H√ÄM ANIMATION CH√çNH ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // L√†m m∆∞·ª£t chuy·ªÉn ƒë·ªông tay
            lerpHandX += (handX - lerpHandX) * 0.1;
            lerpHandY += (handY - lerpHandY) * 0.1;

            const targetRotY = (lerpHandX - 0.5) * Math.PI * 4;
            const targetRotX = (lerpHandY - 0.5) * Math.PI * 2;

            updateSystem(groupGold, state, targetRotX, targetRotY);
            updateSystem(groupRed, state, targetRotX, targetRotY);
            updateSystem(groupGifts, state, targetRotX, targetRotY);

            // X·ª≠ l√Ω Logic Tr·∫°ng th√°i
            if (state === 'EXPLODE') {
                titleMesh.visible = false;
                let maxZ = -1000;
                photoMeshes.forEach((m, i) => {
                    m.visible = true;
                    m.position.lerp(m.userData.spherePos, 0.1);
                    m.lookAt(camera.position);

                    const worldPos = new THREE.Vector3();
                    m.getWorldPosition(worldPos);
                    if(worldPos.z > maxZ) { maxZ = worldPos.z; selectedIndex = i; }
                    
                    const s = worldPos.z > 20 ? 1.5 : 0.8;
                    m.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
                });
            } else if (state === 'PHOTO') {
                photoMeshes.forEach((m, i) => {
                    if(i === selectedIndex) {
                        m.position.lerp(new THREE.Vector3(0, 0, 80), 0.1);
                        m.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                        m.lookAt(camera.position);
                    } else {
                        m.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                    }
                });
            } else {
                titleMesh.visible = true;
                photoMeshes.forEach(m => { m.visible = false; m.scale.set(0,0,0); });
            }

            renderer.render(scene, camera);
        }

        function updateSystem(group, targetState, rotX, rotY) {
            const pos = group.geometry.attributes.position.array;
            const targets = (targetState === 'PHOTO') ? group.userData.explode : group.userData[targetState.toLowerCase()] || group.userData.tree;
            
            for(let i=0; i<pos.length; i++) {
                pos[i] += (targets[i] - pos[i]) * 0.12;
            }
            group.geometry.attributes.position.needsUpdate = true;
            
            if(targetState !== 'TREE') {
                group.rotation.y += (rotY - group.rotation.y) * 0.1;
                group.rotation.x += (rotX - group.rotation.x) * 0.1;
            } else {
                group.rotation.y += 0.01;
                group.rotation.x *= 0.9;
            }
        }

        // --- MEDIA PIPE & CAMERA ---
        async function startSystem() {
            document.getElementById('interface').style.display = 'none';
            bgMusic = new Audio('./audio.mp3'); bgMusic.loop = true; bgMusic.play();

            createScene();

            const video = document.querySelector('.input_video');
            const camCanvas = document.getElementById('camera-canvas');
            const camCtx = camCanvas.getContext('2d');

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                // T·ªëi ∆∞u v·∫Ω Camera HD
                if(results.image) {
                    camCanvas.width = results.image.width; camCanvas.height = results.image.height;
                    camCtx.save();
                    camCtx.clearRect(0,0,camCanvas.width, camCanvas.height);
                    camCtx.drawImage(results.image, 0, 0, camCanvas.width, camCanvas.height);
                    camCtx.restore();
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x; handY = lm[9].y;

                    // Nh·∫≠n di·ªán c·ª≠ ch·ªâ
                    const distPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    const fingerTips = [8, 12, 16, 20];
                    let openFingers = 0;
                    fingerTips.forEach(idx => {
                        if(lm[idx].y < lm[idx-2].y) openFingers++;
                    });

                    if (distPinch < 0.04) state = 'PHOTO';
                    else if (openFingers > 2) state = 'EXPLODE';
                    else state = 'TREE';
                } else {
                    state = 'TREE';
                }
            });

            const cameraPipe = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: CONFIG.cameraHD.width, height: CONFIG.cameraHD.height
            });
            cameraPipe.start();
        }

        document.getElementById('start-btn').addEventListener('click', startSystem);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
